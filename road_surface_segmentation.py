# -*- coding: utf-8 -*-
"""Road_Surface_Segmentation.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/14nmANqAy483DYQwpcmY5-k0pYhrtFqYk
"""

import cv2 as cv
import numpy as np
import tensorflow as tf
import argparse
import sys
import os.path
import random
import os
import glob
import operator

'''
# Commented out IPython magic to ensure Python compatibility.
# Download the dataset from GitHub
!rm -rf /content/Image/
!rm -rf /content/Road_Surface_Classification/Image/
!git clone https://github.com/Swagat18012001/Road_Surface_Classification.git
!rm -rf /content/Image/
# %ls /content/Road_Surface_Classification/
'''
'''
tf.compat.v1.disable_eager_execution()

image_size=128
num_channels=3
images = []

outputFile = sys.argv[2]
'''

tf.compat.v1.disable_eager_execution()

image_size=128
num_channels=3
images = []

# Check for command-line arguments
if len(sys.argv) != 3:
    print("Usage: python script.py <input_video_path> <output_video_path>")
    sys.exit(1)

input_video_path = sys.argv[1]
output_video_path = sys.argv[2]

'''
# Opening frames
cap = cv.VideoCapture(sys.argv[1])

vid_writer = cv.VideoWriter(outputFile, cv.VideoWriter_fourcc('M','J','P','G'), 15, (round(cap.get(cv.CAP_PROP_FRAME_WIDTH)),round(cap.get(cv.CAP_PROP_FRAME_HEIGHT))))

width = int(round(cap.get(cv.CAP_PROP_FRAME_WIDTH)))
height = int(round(cap.get(cv.CAP_PROP_FRAME_HEIGHT)))

newHeight = int(round(height/2))
'''

# Opening frames
cap = cv.VideoCapture(input_video_path)
if not cap.isOpened():
    print("Error: Could not open input video.")
    #sys.exit(1)

vid_writer = cv.VideoWriter(output_video_path, cv.VideoWriter_fourcc('M','J','P','G'), 15,
                            (round(cap.get(cv.CAP_PROP_FRAME_WIDTH)), round(cap.get(cv.CAP_PROP_FRAME_HEIGHT))))
if not vid_writer.isOpened():
    print("Error: Could not open output video for writing.")
    #sys.exit(1)

width = int(round(cap.get(cv.CAP_PROP_FRAME_WIDTH)))
height = int(round(cap.get(cv.CAP_PROP_FRAME_HEIGHT)))
newHeight = int(round(height / 2))

'''
# Restoring the model
sess = tf.compat.v1.Session()
saver = tf.compat.v1.train.import_meta_graph('/content/Road_Surface_Classification/roadsurface-model.meta')
checkpoint = tf.train.latest_checkpoint('/content/Road_Surface_Classification/checkpoint.txt')

if checkpoint:
  saver.restore(sess, checkpoint)
else:
  print('No checkpoint found')
'''

# Restoring the model
sess = tf.compat.v1.Session()
saver = tf.compat.v1.train.import_meta_graph('/content/Road_Surface_Classification/roadsurface-model.meta')
checkpoint = tf.train.latest_checkpoint('/content/Road_Surface_Classification/checkpoint.txt')

if checkpoint:
  saver.restore(sess, checkpoint)
else:
  print('No checkpoint found')
  #sys.exit(1)

'''
# Acessing the graph
graph = tf.compat.v1.get_default_graph()

y_pred = graph.get_tensor_by_name("y_pred:0")
x = graph.get_tensor_by_name("x:0")
y_true = graph.get_tensor_by_name("y_true:0")
y_test_images = np.zeros((1, len(os.listdir('/content/Road_Surface_Classification/Image'))))

while cv.waitKey(1) < 0:

    hasFrame, images = cap.read()

    finalimg = images

    if not hasFrame:
        print("Classification done!")
        print("Results saved as: ", outputFile)
        cv.waitKey(3000)
        break

    images = images[newHeight-5:height-50, 0:width]
    images = cv.resize(images, (image_size, image_size), 0, 0, cv.INTER_LINEAR)
    images = np.array(images, dtype=np.uint8)
    images = images.astype('float32')
    images = np.multiply(images, 1.0/255.0)

    x_batch = images.reshape(1, image_size, image_size, num_channels)

    #
    feed_dict_testing = {x: x_batch, y_true: y_test_images}
    result = sess.run(y_pred, feed_dict=feed_dict_testing)

    outputs = [result[0,0], result[0,1], result[0,2]]

    value = max(outputs)
    index = np.argmax(outputs)

    if index == 0:
        label = 'Asphalt'
        #prob = str("{0:.2f}".format(value))
        color = (0, 0, 0)
    elif index == 1:
        label = 'Paved'
        #prob = str("{0:.2f}".format(value))
        color = (153, 102, 102)
    elif index == 2:
        label = 'Unpaved'
        #prob = str("{0:.2f}".format(value))
        color = (0, 153, 255)

    # Display the road type classification result
    prob = "{0:.2f}".format(value)
    print(f"Detected road type: {label} with confidence {prob}")

    cv.rectangle(finalimg, (0, 0), (145, 40), (255, 255, 255), cv.FILLED)
    cv.putText(finalimg, 'Class: ', (5,15), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,0), 1)
    cv.putText(finalimg, label, (70,15), cv.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
    cv.putText(finalimg, prob, (5,35), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0,0,0), 1)


    vid_writer.write(finalimg.astype(np.uint8))

sess.close()
'''

# Accessing the graph
graph = tf.compat.v1.get_default_graph()
y_pred = graph.get_tensor_by_name("y_pred:0")
x = graph.get_tensor_by_name("x:0")
y_true = graph.get_tensor_by_name("y_true:0")
y_test_images = np.zeros((1, len(os.listdir('/content/Road_Surface_Classification/Image'))))

while cv.waitKey(1) < 0:
    hasFrame, frame = cap.read()

    if not hasFrame:
        print("Classification done!")
        print("Results saved as: ", output_video_path)
        break

    # Preprocess the frame
    processed_frame = frame[newHeight-5:height-50, 0:width]
    processed_frame = cv.resize(processed_frame, (image_size, image_size), 0, 0, cv.INTER_LINEAR)
    processed_frame = np.array(processed_frame, dtype=np.uint8)
    processed_frame = processed_frame.astype('float32')
    processed_frame = np.multiply(processed_frame, 1.0 / 255.0)

    x_batch = processed_frame.reshape(1, image_size, image_size, num_channels)

    # Run the model
    feed_dict_testing = {x: x_batch, y_true: y_test_images}
    result = sess.run(y_pred, feed_dict=feed_dict_testing)

    # Process the result
    outputs = [result[0, 0], result[0, 1], result[0, 2]]
    value = max(outputs)
    index = np.argmax(outputs)

    if index == 0:
        label = 'Asphalt'
        prob = str("{0:.2f}".format(value))
        color = (0, 0, 0)
    elif index == 1:
        label = 'Concrete'
        prob = str("{0:.2f}".format(value))
        color = (153, 102, 102)
    elif index == 2:
        label = 'Unpaved'
        prob = str("{0:.2f}".format(value))
        color = (0, 153, 255)

    # Debug print
    print(f"Frame classified as {label} with probability {prob}")

    # Draw the result on the frame
    cv.rectangle(frame, (0, 0), (200, 40), (255, 255, 255), cv.FILLED)
    #cv.putText(frame, f'Class: {label}', (5, 15), cv.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
    #cv.putText(frame, f'Prob: {prob}', (5, 35), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)
    # Put the text on the image
    cv.putText(frame, 'Class: ', (5, 15), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)
    cv.putText(frame, label, (70, 15), cv.FONT_HERSHEY_SIMPLEX, 0.5, color, 1)
    cv.putText(frame, prob, (5, 35), cv.FONT_HERSHEY_SIMPLEX, 0.5, (0, 0, 0), 1)

    vid_writer.write(frame.astype(np.uint8))

sess.close()
cap.release()
vid_writer.release()

'''
from google.colab import files
files.download('/root/.local/share/jupyter/runtime/kernel-390d05bf-9d13-4112-b35e-d426eb725d5c.json')
'''









